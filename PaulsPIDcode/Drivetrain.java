// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

package org.usfirst.frc4513.MystStraightPlusTurnInPlace.subsystems;

import org.usfirst.frc4513.MystStraightPlusTurnInPlace.RobotMap;

import com.kauailabs.navx.frc.AHRS;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDController;
import edu.wpi.first.wpilibj.PIDOutput;
import edu.wpi.first.wpilibj.PIDSource;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

/***
 * This drivetrain subsystem contains PID routines for turn in-place and following straight
 * paths. Following multi-segment paths that include arcs is still in work. I am pursuing a
 * couple of ideas for that, but it is pretty much the lowest priority for robot testing time 
 * at this point.
 * 
 *  * @author Paul
 */

public class Drivetrain extends Subsystem 
{
	// AUTO_PATH mode is included for future expansion
	public enum DriveMode {TELE, AUTO_ROTATE, AUTO_STRAIGHT, AUTO_PATH} ;
	
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS 

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final SpeedController frontLeftSpdCtr = RobotMap.drivetrainFrontLeftSpdCtr;
    private final SpeedController frontRightSpdCtr = RobotMap.drivetrainFrontRightSpdCtr;
    private final SpeedController rearLeftSpdCtr = RobotMap.drivetrainRearLeftSpdCtr;
    private final SpeedController rearRightSpdCtr = RobotMap.drivetrainRearRightSpdCtr;
    private final RobotDrive robotDrive41 = RobotMap.drivetrainRobotDrive41;
    private final Encoder leftDriveEncoder = RobotMap.drivetrainLeftDriveEncoder;
    private final Encoder rightDriveEncoder = RobotMap.drivetrainRightDriveEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new StopAutoDrive()); 
    }
    
	// PID constants
    // These are for straight path
    // Adding KD is a potential way to eliminate need for a variable KP based on distance.
    // I have done the sims both ways. Variable KP-only is workable, and can sometimes be a formula based
    // on distance, but it becomes more difficult in the face of rolling friction and static friction. 
    // My physics sims were more workable with a static KP and KD. 
    // These look like reasonable starting points if distance setpoint ramping is turned off (large change allowed)
	// static private double KP_STRAIGHT = 0.7 ;
	// static private double KD_STRAIGHT = 1.4 ;
    // These look like better starting points if distance setpoint ramping is at 3-6 ft/sec = 0.15-0.30 ft/update
	static private double KP_STRAIGHT = 0.4 ;
	static private double KD_STRAIGHT = 3.5 ;
	
	// This is for drift correction. I don't have a sim of this so this is a pretty much a guess for now.
	// Suggest starting pretty low to see how much drift there is in the first place.
	static private double KP_DRIFT = 0.015 ;
	
	// These are for in-place rotation, same comments for KD as above
	// Tune these at the most common range of in-place rotations. For 2018 that would seem to be 90 deg if
	// this is even used at all. Currently it is a backup plan to curved paths.
	// 1-16-18 on Myst: these worked well for 90 degrees. 
	// This KP makes 45 a bit slow. KP=0.015 makes 45 faster but causes some overshoot at 90. Correction of 
	// small overshoots becomes problematic due to static friction, and it appears that the bang-bang below is not always
	// able to deal with it, so best to avoid it in the first place if possible. More investigation is warranted.
	// Variable KP-only is also an alternative here. 
	static private double KP_ROT = 0.010 ; // 0.015 ;	
	static private double KD_ROT = 0.017 ; 
	
	// PID assumes the plant's response to control inputs acts like a linear operator (not same as a linear fn), meaning:
	// f(u) + f(v) = f(u+v), where f is the plant response and u and v are functions of time (input control signals)
	// and f(c*u) = c*f(u), where c is a constant scalar.
	// Both static and dynamic friction violate this. One way to deal with stiction is to establish a minimum output from 
	// the PID, which is what I'm using here (in some cases the underlying PWM can be modified to accomplish that). PID 
	// theory and physics sim shows that this is workable.
	// The idea is that the motor commands operate in bang-bang mode at the upper threshold when the PID command output is between 
	// these numbers. 
	// NOTE 1: For distance PID, this is only necessary for small distance steps, where KP*distance would not be enough
	//         to get the robot moving. In longer steps, sims indicate it should work on or off.
	//         For now this is commented out in the distance PID.
	// NOTE 2: Turning in place generally requires small corrections that can't overcome stiction, and sims indicate this should 
	//         be on for reliability. Otherwise both Kp and Kd become dependent on the turn size, and the relationship isn't 
	//         simple across a 20-180 degree range. If the achievable accuracy turns out to be insufficient, probably the next
	//         approach to pursue would be turn-dependent PID gains (and variable KP only might be possible).
	// The upper threshold should be at the minimum command to each side that will get the robot moving
	// The lower threshold should be some low number so that the PID can get out of bang-bang oscillation when we are close to 
	// the target (although we will also turn off the PID when we are close anyway).
	// Can turn this off by making them the same.
	// 1-16-18 on Myst: these numbers worked reasonable well for point turn. 0.3 was too low for the upper threshold.
	// I suspect this will need to change for a 4 wheel drive system (where small corrections can be expected to be even harder)
	static private double BBANG_UPPER_THRESH = 0.4 ; 
	static private double BBANG_LOWER_THRESH = 0.01 ;
	
	// This adds "setpoint ramping" which is a common approach in PID that limits the rate of change of 
	// the desired setpoint. The caller can make a step change, but it is fed to the PID in a ramp established by 
	// this parameter. This is one approach to solving "integral windup" problems (not the case here) or when
	// a KD term cannot compensate for overshoot due to huge derivatives (which is a problem here).
	// Sim indicates it is optional for straight distance PID, and not particularly helpful for rotation in place.
	// A worry with curve following is that we're not automatically slowing down as we enter the next segment, like
	// 3.0 ft/sec = 0.15 ft/update = 1.8 in/update would get us to a 15 ft destination in 5 secs (1/3rd the autonomous 
	// time period, which seems reasonable) with the potential of overshooting a transition as much as 0.8 inch.
	// We might want to experiment with increasing the PIDController update interval as well (see the 4th constructor).
	// If this is turned off for purely straight segs, it affects KP and KD (see above).
	// 1-15-18 on Myst: increasing this to 0.3 (6 ft/sec) still works well up to 8 ft for straight line.
	static private double MOVE_RATE = 0.15 ;      // 3 ft/sec*.05 sec/update = 0.15 ft/update = 1.8 in/update    
	// static private double MOVE_RATE = 0.3 ;    // 6 ft/sec max ramp up
	
	// At present I'm not thinking this is helpful for in-place rotations
	// static private double ROTATE_RATE = 1.0 ;  // deg per update 1.0/0.05 = 20 deg/sec
	
	// tolerance for when we've reached our target distance or target rotation
	static final private double ABS_TOL_IN = 1.0 ;  
	static final private double ABS_TOL_DEG = 1.0 ;
	
	// encoder constants from the part specifications (note they are different left and right)
	static final private double WHEEL_RADIUS_IN = 2.0 ;
	static final private double LEFT_ENCODER_PPR = 360 ;  // 1440 ;  
	static final private double RIGHT_ENCODER_PPR = 250 ; // 1000 ;  
	
	// these are computed based on the above constants
	// if you multiply these out they are close to the hard coded constants in the C++ code (which I'm told were
	// obtained experimentally), but computing these from the part specs (above) makes them easier to adjust. 
	// Experimental verification is of course still useful, but it is always comforting to know that experiment 
	// and theory agree (or at least the extent to which they do).
	// For either set of values I'm tending to read consistently longer on the left than the right, even when drift 
	// is not apparent. Pick your poison for now, but another calibration pass might be in order.
	//
	// this comes out to 0.0349 in per pulse
	static final private double LEFT_ENCODER_IN_PER_PULSE = 2.0*Math.PI*WHEEL_RADIUS_IN/LEFT_ENCODER_PPR ;
	// this comes out to 0.0503 in per pulse 
	// static final private double RIGHT_ENCODER_IN_PER_PULSE = 2.0*Math.PI*WHEEL_RADIUS_IN/RIGHT_ENCODER_PPR ;
	// 
	// these are the numbers hard coded in Myst3 C++ code:
	// static final private double LEFT_ENCODER_IN_PER_PULSE = 0.0354062 ;  // pretty sure this is slightly high
	static final private double RIGHT_ENCODER_IN_PER_PULSE = 0.05084746 ;   // might work better than the calc'd?
	
	// robot left/right wheel distance from center
	static final private double DRIVETRAIN_RADIUS_IN = 14 ; 
	
    // this keeps track of our current drive mode
    private DriveMode mDriveMode = DriveMode.TELE ;

    // IMU
	private AHRS mAHRS = new AHRS(SPI.Port.kMXP);
	
	// PID Controller
	private PIDController mPidController = null ;
	private DistancePidIO mDistancePidIO = null ;
	private RotationPidIO mRotatePidIO = null ;
		
    // no-arg constructor
    public Drivetrain() {
        // set the Inches per pulse for each encoder (this overrides anything Robotbuilder generates in RobotMap.java)
    	leftDriveEncoder.setDistancePerPulse(LEFT_ENCODER_IN_PER_PULSE);
    	rightDriveEncoder.setDistancePerPulse(RIGHT_ENCODER_IN_PER_PULSE);
    	
    	// put current defaults for tuning parameters on dashboard
    	// (a network table could also be used)
    	SmartDashboard.putNumber("KP_STRAIGHT", KP_STRAIGHT) ;  
    	SmartDashboard.putNumber("KP_ROT", KP_ROT) ;  
    	SmartDashboard.putNumber("KP_DRIFT", KP_DRIFT) ;  
    	SmartDashboard.putNumber("KD_STRAIGHT", KD_STRAIGHT) ;  
    	SmartDashboard.putNumber("KD_ROT", KD_ROT) ;  
    	SmartDashboard.putNumber("BB_UPPER", BBANG_UPPER_THRESH) ;  
    	SmartDashboard.putNumber("BB_LOWER", BBANG_LOWER_THRESH) ;  
    	SmartDashboard.putNumber("MOVE_RATE", MOVE_RATE) ;
    	// SmartDashboard.putNumber("ROTATE_RATE", ROTATE_RATE) ;
    }
    
    // a Command can call this to see if we're done
    public DriveMode getDriveMode() {   
    	return mDriveMode ;   
    }
    
    // a Command can call this to force a stop (e.g., from a watchdog timer)    
	public void stopAutomation() {
		// stop the drive motors and shutdown automation
		System.out.println("****** STOPPING AUTOMATION *****") ;
		if (mDistancePidIO!=null)
			mDistancePidIO.stop();
		if (mRotatePidIO!=null)
			mRotatePidIO.stop();
		if (mPidController!=null) {
			mPidController.reset() ;
			mPidController.disable();
			mPidController.free();
			mPidController = null ;			
		}
		mDriveMode = DriveMode.TELE ;
		robotDrive41.tankDrive(0, 0);
	}
	
    // --------------------------------------------------------------------------------
    // a command calls this to start automated distance PID to drive straight
    // --------------------------------------------------------------------------------
    public void driveStraight(double distanceFt) {
    	// grab the relevant coefficients for tuning
    	// (these can be removed from the smart dashboard once tuning is finalized)
    	KP_STRAIGHT = SmartDashboard.getNumber("KP_STRAIGHT", KP_STRAIGHT) ;
    	KD_STRAIGHT = SmartDashboard.getNumber("KD_STRAIGHT", KD_STRAIGHT) ;
    	KP_DRIFT = SmartDashboard.getNumber("KP_DRIFT", KP_DRIFT) ;  
    	BBANG_UPPER_THRESH = SmartDashboard.getNumber("BB_UPPER", BBANG_UPPER_THRESH) ;  
    	BBANG_LOWER_THRESH = SmartDashboard.getNumber("BB_LOWER", BBANG_LOWER_THRESH) ;
        MOVE_RATE = SmartDashboard.getNumber("MOVE_RATE", MOVE_RATE) ;
        
    	// create a PIDController
    	// NOTES: by default these update every 50 msec (not 20) whereas Motor Safety default is at 100 msec
    	// An encoder can be specified as the PIDSource directly, but we need the average of two encoders
    	mDistancePidIO = new DistancePidIO(distanceFt) ;
    	// no KI, no KF, pidIO object provides both the source data and handles the PID output 
  		mPidController = new PIDController(KP_STRAIGHT, 0, KD_STRAIGHT, 0, mDistancePidIO, mDistancePidIO);
  		// in this case (non-normalized setpoint) we don't need to set an input range
   		mPidController.setOutputRange(-1, +1);
   		// do not wrap min and max inputs to the same point (like we do for rotations)
   		mPidController.setContinuous(false);  
   		// this only matters if we ask the PID when we're done, as opposed to testing that ourselves
   		mPidController.setAbsoluteTolerance(ABS_TOL_IN);   

    	// put us in PID mode
    	mDriveMode = DriveMode.AUTO_STRAIGHT ;

  		// start PID Source on the first segment
  		mDistancePidIO.start() ;
  	}
    
    // --------------------------------------------------------------------------------
    // PIDSource and Output for Segment following mode
    // --------------------------------------------------------------------------------
	private class DistancePidIO implements PIDSource, PIDOutput 
	{
		private double              mTotalDistFt = 0 ;           // the total path distance
		private double              mRateLimitTargetDist  ;      // the present setpoint-limited distance
        private boolean             mIsActive = false ;
        private int                 mLogCounter = 0 ;            // used to filter the volume
		
		// constructor
		public DistancePidIO(double distanceFt) {
			mTotalDistFt = distanceFt ;
		}

		// call this to start the PID IO
		public void start() {
	    	// reset the encoder counts
	  		leftDriveEncoder.reset();
	  		rightDriveEncoder.reset();
	  		
	  		// reset the IMU
	  		mAHRS.reset();
	  		// mAHRS.zeroYaw();
	  		
			// set the first setpoint, enable the PID, enable the PID I/O
			incrRateLimitTarget() ;
			mPidController.enable();
			mIsActive = true ;
		}
		
		// call this to stop the PID IO
		public void stop() {
			mIsActive = false ;
		}
		
		// This is called to ramp the set point at each time step
		// NOTE: assuming only positive distances for now (not hard to extend for backing)
		// return true if done ramping up to the desired set point
		private boolean incrRateLimitTarget() {
			if (mTotalDistFt > mRateLimitTargetDist) {
				mRateLimitTargetDist += MOVE_RATE ;
				// it's possible that moves us past the end
			    if (mRateLimitTargetDist > mTotalDistFt)
			    	mRateLimitTargetDist = mTotalDistFt ;
			    
			    // adjust the set point
				mPidController.setSetpoint(mRateLimitTargetDist) ; 
	            return false ;				
			}
			return true ;
		}

		// PID output is called by mPidController to provide the PID output value
		@Override
		public void pidWrite(double pidOutput) {
			if (!mIsActive) return ; 
			
			// first apply bang-bang thresholding to the command (when desired)
			// pidOutput = driveBangBang(pidOutput) ;
			
	    	// straight paths should follow a (relative) yaw of zero
			// partition pidOutput based on difference between our expected and actual yaw
			// if going straight, a pos yaw means we're drifting to the right (increase right, decrease left)
			double yawerr = mAHRS.getAngle() ;

	    	if (mLogCounter==0)	System.out.println("*** ACTUAL AZ=" + yawerr + " ***") ;

			// adjust wheel power for drift
	    	// The arcadeDrive dir could be used here, but this is more complicated for curved paths, where the calculation
	    	// is a bit simpler for tankDrive. This code is based on the curved path code, so I left it at tankDrive.
			double left = pidOutput  * (1 - yawerr * KP_DRIFT) ;
			double right = pidOutput * (1 + yawerr * KP_DRIFT) ;
			// make sure the larger drive magnitude isn't bigger than 1
			// there is some possibility of one side falling below Bang Bang thresh here (if using that)
			// that could be dealt with, but not worrying about it for now since don't expect to use it here
			double max = Math.max(Math.abs(left), Math.abs(right)) ;
			if (max > 1) {
				left = left / max ;
				right = right / max ;
			}
			
	    	if (mLogCounter==0) System.out.println("*** PIDOUT=" + pidOutput + " Left="+left + " Right="+right + " ***") ;

	    	robotDrive41.tankDrive(left, right);				

			// now check to see if we're within (absolute) tolerance for the end of the current segment
			// these are in inches
	    	// API docs imply that we can't use onTarget() unless we constrain the setpoint range. I suspect that onTarget() still works
	    	// if setAbsoluteTolerance() is used instead of setTolerance(), but since I needed to do it manually for multi-segment following
	    	// (and hence hadn't tested the use of onTarget() with setAbsoluteTolerance()), I'm still testing it manually here.
	    	// NOTE: if the PID doesn't shut itself off, that means we stopped moving without reaching this tolerance
	    	double leftDist = leftDriveEncoder.getDistance() ;
	    	double rightDist = rightDriveEncoder.getDistance() ;
	    	// if we're within tolerance of the end point, shut down the PID
	    	double error = Math.abs((leftDist+rightDist)/2.0 - mTotalDistFt*12.0) ;
    	    if (error <= ABS_TOL_IN) {
	    		stopAutomation() ; 
   	    		return ;	    		
    	    }

	    	// now ramp the set point if applying set point limiting
			incrRateLimitTarget() ; 

			// log messages on every fifth update
			mLogCounter = (mLogCounter+1)%5 ;
		}

		// three methods required for interface PIDSource
	    // in this case the PID source is the distance along the arc
		// we need to return our progress so that the PID can calculate error and next command
		@Override
		public double pidGet() {
			// these are in inches
	    	double leftDist = leftDriveEncoder.getDistance()/12.0 ;
	    	double rightDist = rightDriveEncoder.getDistance()/12.0 ;
	    	double aveDist = (leftDist + rightDist) / 2.0 ;
	    	return aveDist ;
		}		

		@Override
		public void setPIDSourceType(PIDSourceType pidSource) {
			// We don't really need to do anything here
			// because we don't allow other source types
		}

		@Override
		public PIDSourceType getPIDSourceType() {
			// We are providing a displacement (based on encoders)
			return PIDSourceType.kDisplacement ;
		}

	}	
    // --------------------------------------------------------------------------------
	
    // --------------------------------------------------------------------------------
	// start a PID rotation
    // --------------------------------------------------------------------------------
	public void pidRotateTo(double angleDeg) {
    	KP_ROT = SmartDashboard.getNumber("KP_ROT", KP_ROT) ;
    	KD_ROT = SmartDashboard.getNumber("KD_ROT", KD_ROT) ;
    	BBANG_UPPER_THRESH = SmartDashboard.getNumber("BB_UPPER", BBANG_UPPER_THRESH) ;  
    	BBANG_LOWER_THRESH = SmartDashboard.getNumber("BB_LOWER", BBANG_LOWER_THRESH) ;
        // ROTATE_RATE = SmartDashboard.getNumber("ROTATE_RATE", ROTATE_RATE) ;
    	
    	mRotatePidIO = new RotationPidIO(angleDeg) ;
		mPidController = new PIDController(KP_ROT, 0, KD_ROT, 0, mRotatePidIO, mRotatePidIO) ;
		mPidController.setInputRange(-180, +180); 
		mPidController.setContinuous(true);                 // so the angle error wraps around
		mPidController.setOutputRange(-1, +1);
		mPidController.setAbsoluteTolerance(ABS_TOL_DEG); 

		mDriveMode = DriveMode.AUTO_ROTATE ;
		
		// reset the Yaw gyro to 0 at the start of every turn request
		// note that it will drift up to 1 deg per minute
		mAHRS.reset();
		// mAHRS.zeroYaw();
		
		// reset the integral and prev errors as well
		mPidController.reset();
		mPidController.setSetpoint(angleDeg);
		mPidController.enable();
		
		mRotatePidIO.start();
	}
		
    // --------------------------------------------------------------------------------
    // PIDSource and Output for Rotation
    // --------------------------------------------------------------------------------
	private class RotationPidIO implements PIDSource, PIDOutput
	{
		private double mTargetDeg = 0 ;
		private boolean mIsActive = false ;
		// private double mRateLimitTarget = 0 ;
		
		public RotationPidIO(double angleDeg) {
			// enforce a range of -180 to +180
			mTargetDeg = angleDeg ;
			if (mTargetDeg>180)	mTargetDeg = 180 ;
			if (mTargetDeg<-180) mTargetDeg = -180 ;
		}
		
		public void stop() {
			mIsActive = false ;
		}
		
		public void start() {
			mIsActive = true ;
		}

		@Override
		public void pidWrite(double output) { 
			if (!mIsActive) return ;

			// SmartDashboard.putNumber("PIDOUT", output);
			// drive the motors with the PID output
			output = driveBangBang(output) ;
	        robotDrive41.tankDrive(output, -output);

	    	double yaw = mAHRS.getAngle() ;
	    	double error = Math.abs(yaw - mTargetDeg);
	    	if (error <= ABS_TOL_DEG)
				stopAutomation();
		}

		// we could specify mAHRS directly as the PID source
		// but this gives us a chance to play some games
		// with normalization or rate limiting if necessary
		@Override
		public double pidGet() {
			// incrRateLimitTarget() ; 
			return mAHRS.getAngle() ;
		}
		
		@Override
		public void setPIDSourceType(PIDSourceType pidSource) {
		}

		@Override
		public PIDSourceType getPIDSourceType() {
			return PIDSourceType.kDisplacement ;
		}
	}
	
	private double driveBangBang(double cmd) {
		if ((cmd<BBANG_UPPER_THRESH) && (cmd>BBANG_LOWER_THRESH))
			return BBANG_UPPER_THRESH ;
		if ((cmd>-BBANG_UPPER_THRESH) && (cmd<-BBANG_LOWER_THRESH))
			return -BBANG_UPPER_THRESH ;
		return cmd ;
	}
	
	// this enforces set point limiting (at present, don't expect to need that for turning)
	// this one works for both turn directions
	/***
	private boolean incrRateLimitTarget() {
		if (mTargetDeg > 0) {
			if (mTargetDeg > mRateLimitTarget) {
				mRateLimitTarget += ROTATE_RATE ;
				if (mRateLimitTarget > mTargetDeg)
		    	   mRateLimitTarget = mTargetDeg ;
				mPidController.setSetpoint(mRateLimitTarget) ; 
				return false ;				
		    }
		}
		else {
			if (mTargetDeg < mRateLimitTarget) {
				mRateLimitTarget -= ROTATE_RATE ;
				if (mRateLimitTarget < mTargetDeg)
		    	   mRateLimitTarget = mTargetDeg ;
				mPidController.setSetpoint(mRateLimitTarget) ; 
				return false ;
			}
		}
		return true ;
	}
	***/
}

